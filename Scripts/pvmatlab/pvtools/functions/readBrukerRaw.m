function [ data , addInfo] = readBrukerRaw(Acqp, varargin)
% function [ data , addInfo ] = readBrukerRaw(Acqp, [Method], [path_to_DataFile], ['specified_NRs', NR_array], 
%                                    ['specified_Jobs', job_array], ['precision', precision_string],
%                                    ['fid_proc'])
% Input:
%   Acqp (struct): An acqp struct as generated by the function readBrukerParamFile('path/acqp')
%
% Optional inputs:
%   Method: A method parameter struct as generated by the function
%           readBrukerParamFile('path/method'). Method parameters are 
%           needed in combination with the 'fid_proc' option for PV 360
%           data.
%
%   path_to_dataFile (string): path to fid-data including the file name (fid or rawdata.job0)
%   
%   'specified_NRs', NR_array: If you are using a standard fid file, you can specify a list of NRs 
%                              to be read, NR starting with 1 
%                              'specified_NRs',[2 5 7] -> only NR 2, 5 and 7 are read
%
%   'specified_Jobs', job_array: If you are using jobs in your acquisition, you can specify
%                                a list of jobs you want to read, the first job is job0. If you 
%                                want to read only the fid-file and no job, you can use
%                               'specified_Jobs',[ -1 ]
%
%   'precision', precision_string: You can define the precision of the imported data: 
%                                  'single' or 'double' (default). Single precision uses 4 bytes to
%                                  represent a (real) floating point number, 'double' uses 8 bytes.
%
%   'fid_proc': Set this flag to override reading the native rawdata.job0 and instead read
%               the pre-processed '<EXPNO>/fid', or '<PROCNO>/fid_proc.64' for ParaVision 360 V3.0
%               and later, respectively. This pre-processed fid, as created by some methods (e.g.,
%               CSI, PRESS and STEAM) is created from the raw data by performing phase corrections, 
%               averages, combining the receive channels and (for CSI) Fourier transforming in the
%               spatial directions.
% Output:
%   data: - If path_to_dataFile contains only an fid file, or an fid file plus job files and 
%           'specified_Jobs' is set to [ -1 ], data is a cell with a 3D matrix of size 
%           (ScanSize, numScans, numChannels)
%         - If path_to_dataFile contains job files, data is a cell array with 
%           {job0, job1, job2, ...}, in which job* are 3D matrices  of size 
%           (numChannels, ScanSize, numScans)
%
%  addInfo (struct) contains information about the selected receivers, specified NRs or specified jobs


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Copyright (c) 2013 - 2020
% Bruker BioSpin MRI GmbH
% D-76275 Ettlingen, Germany
%
% All Rights Reserved
%
% $Id$
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------
    %% get optional Method input
    if ~isempty(varargin) && isstruct(varargin{1})
        Method=varargin{1};
        varargin=varargin(2:end);
    else
        Method=struct();
    end

    %% Check version using ACQ_sw_version
    if bruker_getAcqPvVersion(Acqp, 'is360')
        [ data , addInfo] = readBrukerRawFromPv360(Acqp, Method, varargin{:});
    else
        [ data , addInfo] = readBrukerRawTillPv360(Acqp, varargin{:});
    end
end
            
            
%----------------------------------------------------------------
function [ data , addInfo] = readBrukerRawTillPv360(Acqp, varargin)
    %% Define default-value if necesseary:
    
    % Set Parameters of InputParser (Matlab-function)
    [varargin, specified_NRs]=bruker_addParamValue(varargin, 'specified_NRs', '@(x) isnumeric(x)', []);
    [varargin, specified_Jobs]=bruker_addParamValue(varargin, 'specified_Jobs', '@(x) isnumeric(x)', []);
    [varargin, precision]=bruker_addParamValue(varargin, 'precision', '@(x) (strcmpi(x,''double'') || strcmpi(x,''single''))', 'double');
    [varargin, fid_proc]=bruker_addFlag(varargin, 'fid_proc', false);
    
    if length(varargin) == 1
        path_to_dataFile=varargin{1};
    elseif isempty(varargin) 
        path_to_dataFile=[filesep, 'fid'];
    else
        warning('MATLAB:bruker_warning', 'Check your input arguments of function readBrukerRaw')
    end
    
%----------------------------------------------------------------   
    %% Check for missing variables in structs:
    cellstruct{1}=Acqp;
     all_here = bruker_requires(cellstruct, {{'Acqp','GO_raw_data_format','BYTORDA','NI','NR','ACQ_size','GO_data_save','GO_block_size', 'AQ_mod'}});
    if isfield(Acqp, 'ACQ_jobs_size')
        all_here = bruker_requires(cellstruct, {{'Acqp','ACQ_jobs','ACQ_jobs_size'}}) & all_here;
        end
    clear cellstruct;
    if ~all_here
        error('Some parameters are missing');
    end

%----------------------------------------------------------------
    %% copy necessary parameters from inputstructs\
    % under this section, the Acqp-struct is not used !
    % makes it easier to find failing parameters for users
    GO_raw_data_format=Acqp.GO_raw_data_format;
    BYTORDA=Acqp.BYTORDA;
    AQ_mod=Acqp.AQ_mod;
    
    % Determining number of selected receive channels
    numSelectedReceivers = bruker_getSelectedReceivers(Acqp);
    
    addInfo.numSelectedReceivers=numSelectedReceivers;
    if ~isempty(specified_NRs)
        addInfo.specified_NRs=specified_NRs;
    end
    if ~isempty(specified_Jobs)
        addInfo.specified_Jobs=specified_Jobs;
    end
    
    %saving the variables to an struct to make function-calls shorter
    paramStruct.NI=Acqp.NI;
    paramStruct.NR=Acqp.NR;
    paramStruct.ACQ_size=Acqp.ACQ_size;
    paramStruct.GO_data_save=Acqp.GO_data_save;
    paramStruct.GO_block_size=Acqp.GO_block_size;
    
    % If Jobs copy variables:
    if isfield(Acqp, 'ACQ_jobs_size') && Acqp.ACQ_jobs_size>0
        jobsExist=true;
        ACQ_jobs=Acqp.ACQ_jobs;
        ACQ_jobs_size=Acqp.ACQ_jobs_size;
        paramStruct.ACQ_jobs=Acqp.ACQ_jobs;
        paramStruct.ACQ_jobs_size=ACQ_jobs_size;
    else
        jobsExist=false;
    end
     
    %----------------------------------------------------------------------
    %% Transform Variables from Acqp-Struct to Matlab readable:

    %transform the Number-Format to Matlab-format (=format) and save the
    %number of bits per value
    switch(GO_raw_data_format)
        case ('GO_32BIT_SGN_INT')
            format='int32';
            bits=32;
        case ('GO_16BIT_SGN_INT')
            format='int16';
            bits=16;
        case ('GO_32BIT_FLOAT')
            format='float32';
            bits=32;
        otherwise
            format='int32';
            disp('Data-Format not correct specified! Set to int32')
            bits=32;
    end

    %transform the machinecode-format to matlab-format (=endian)
    switch(BYTORDA)
        case ('little')
            endian='l';
        case ('big')
            endian='b';
        otherwise 
            endian='l';
            disp('MacineCode-Format not correct specified! Set to little-endian')
    end
    
    % decide if RawFile is complex or real:
    switch AQ_mod
        case ('qf')
            isComplexRaw=false;
        case ('qseq')
            isComplexRaw=true;
        case ('qsim')
            isComplexRaw=true;
        case ('qdig')
            isComplexRaw=true;
        otherwise
            error('The value of parameter AQ_mod is not supported');
    end
        
    %----------------------------------------------------------------------    
    %% Choose the right function(s) for reading:

    if fid_proc
        [ data{1} ] = readFidProcFile(Acqp, paramStruct, path_to_dataFile, specified_NRs, precision, endian);
    elseif ~jobsExist || (length(specified_Jobs)==1 && specified_Jobs(1)==-1)
        % Jobs don't exist or fid is chosen explicitly
        % 'normal' read of fid-File:
        [ data{1} ] = readfidFile(paramStruct, path_to_dataFile, isComplexRaw, specified_NRs, precision,format,bits, endian,numSelectedReceivers);
        
    elseif (ACQ_jobs(1,1)==0) % if ScanSize entry of First job=0 -> 'normal' read of fid-File:
        [ data{1} ] = readfidFile(paramStruct, path_to_dataFile, isComplexRaw, [], precision,format,bits, endian,numSelectedReceivers);
        
        % special case: first job=normal fidFile, but there are more jobs
        % ACQ_jobs_size>=2 => also jobs in this acquisition
        % if length(specified_Jobs)==1 -> if specified_Jobs(1) is not -1 (-1=read no jobs) => start reading
        % if length(specified_Jobs)==1 => start reading
        if (ACQ_jobs_size>=2) && ( ( length(specified_Jobs)==1 && ~(specified_Jobs(1)==-1 ) || length(specified_Jobs)~=1 ))
            if isempty(specified_Jobs) % if no jobs specified: choose all jobs (without job0)
                specified_Jobs=[1:ACQ_jobs_size-1];
            else
                specified_Jobs( (specified_Jobs==0) ) = []; % delete the zero-job if an fidFile exist and the user specified an  
            end        
            [ JobsCell ] = readJobFilesTillPv360(paramStruct, path_to_dataFile, isComplexRaw, specified_Jobs, precision,format,bits, endian,numSelectedReceivers); %=Jobstruct
            data{2:length(JobsCell)} = JobsCell{2:end}; % in this case: JobsCell{1}==[]
            clear JobsCell;
        end
        
        % ~(ACQ_jobs(1,1)==0 => only jobs in this acquisition
        % if length(specified_Jobs)==1 -> if specified_Jobs(1) is not -1 (-1=read no jobs) => start reading
        % if length(specified_Jobs)~=1 => start reading
    elseif (~(ACQ_jobs(1,1)==0)) && ( ( length(specified_Jobs)==1 && ~(specified_Jobs(1)==-1 ) || length(specified_Jobs)~=1 ))
            [ data ] = readJobFilesTillPv360(paramStruct, path_to_dataFile, isComplexRaw, specified_Jobs, precision,format,bits, endian,numSelectedReceivers);
    else
        error('Your AcqpFile has an unallowed job-description, or you specification was not correct');
    end
    
end
                     
function [ fidFile ] = readfidFile(paramStruct, path_to_dataFile, isComplexRaw, specified_NR, precision,format,bits, endian,numSelectedReceivers)
    % check if specified_NR came with input -> set a boolean
    if(isempty(specified_NR))
        isNR_specified=false;
    else
        isNR_specified=true;
    end
    
    %path_to_dataFile=[path_to_dataFile, '/fid'];
    
    % check the value of precision and change it to a boolean
    if(strcmpi('double',precision))
        single_bool=false;
    elseif(strcmpi('single',precision))
        single_bool=true;
    else
        single_bool=false;
        disp('Your precision-input is not correct! Set to double');
    end      
    clear('input', 'precision');
    
% %----------------------------------------------------------------

    %% Failure Check: is data stored?
    
    % check if acqp-parameter is st correctly
    if(strcmpi(paramStruct.GO_data_save,'no'))
            error('myApp:argChk','You didn''t store your acqusition! Please change the parameters in ParaVision to save it.');
    end
%----------------------------------------------------------------
    
    %% Transform Variables from paramStruct-Struct to Matlab readable:
    
    % shorter variable-names: 
    NI=paramStruct.NI;
    NR=paramStruct.NR;
    ACQ_size=paramStruct.ACQ_size;
    
    % Calculating number of elements in higher dimensions
    numDataHighDim=prod(paramStruct.ACQ_size(2:end));
    
    % Calculating block size (non-complex)
    if strcmp(paramStruct.GO_block_size,'Standard_KBlock_Format')
        blockSize = ceil(ACQ_size(1)*numSelectedReceivers*(bits/8)/1024)*1024/(bits/8);
    else
        blockSize = ACQ_size(1)*numSelectedReceivers;
    end
    
    
%----------------------------------------------------------------

    %% Read Process:
    % open file       
    try
        fileID = fopen(path_to_dataFile,'r');
    catch
        fileID = -1;
    end
    if fileID == -1
        % if multi-frame data is loaded in TopSpin, the fid is replaced
        % with a ser file... so try loading ser instead of fid
        if (length(path_to_dataFile) >= 3 && strcmp(path_to_dataFile(end-2:end), 'fid'))
            path_to_dataFile(end-2:end) = 'ser';
            fileID = fopen(path_to_dataFile,'r');
            warning('Cannot open ''fid'', trying ''ser'' instead.');
        end
    end
    if fileID == -1
        error('Cannot open raw data file. Problem opening file %s.',path_to_dataFile);
    end
       
    % check if specific NR's are choosen:
    if isNR_specified     
        %% Special case: read only an specified array of NRs:        
        
        %check if maximum user-selected NR > real NR or if it is an bad
        %value
        if (max(specified_NR)>NR || min(specified_NR) < 1 )
            error('Your selected NR is to high or to low. Don''t forget the smallest value is 1. -> function abort !');
        end
        
        % reconfigure NR (for errorcheck and sorting later):
        NR=length(specified_NR); % (don't save to acqp)
        
        %calculate Size of ONE NR, defined as: blockSize * ACQ_sizes-starting-by-dim2 * NI
        size_NR=blockSize*numDataHighDim*NI;
        
        %calculate matrix-dimensions of ONE NR non-komplex:
        num_columns=numDataHighDim*NI; %Spalten
        num_rows=blockSize; %Zeilen
        
        
        
        % Read process:
        %--------------
        
        %Init:
        if single_bool
            fidFile=zeros( num_rows, length(specified_NR)*num_columns, 'single'); % fidFile=temporary variable for fidFile
        else
            fidFile=zeros( num_rows, length(specified_NR)*num_columns); % fidFile=temporary variable for fidFile
        end
        
        % read th specified NR-Data:        
        for i=1:length(specified_NR)
            % set position in file:
            fseek(fileID, ( specified_NR(i)-1 )*size_NR*bits/8 , 'bof');
            
            %read only one NR with single or double precision:
            if(single_bool)
                Xzw=single(fread(fileID, [num_rows, num_columns], [format, '=>single'], 0 , endian));
            else
                Xzw=fread(fileID, [num_rows, num_columns], format, 0 , endian);
            end         
            % write to the output-variable:
            fidFile(:,(i-1)*num_columns+1:i*num_columns)=Xzw(1:end,:);
        end        
    else 
        %% normal-case: read complete fid-file
        
        %read File to Variable fidFile with fread() and make it single-precision with single():
        %  Attention: Matlab ACQ_size(1) = ACQ_size(0)
        if(single_bool)
            fidFile=( fread(fileID, [blockSize, numDataHighDim*NI*NR], [format, '=>single'], 0, endian) );
        else
            fidFile=fread(fileID, [blockSize, numDataHighDim*NI*NR], format, 0, endian);
        end    
    end
    
    % file close
    fclose(fileID);
    
    %% short errorcheck and cut the zeros
    fidFileSize=numel(fidFile);
    if ~(fidFileSize==blockSize*numDataHighDim*NI*NR)
        error('Size of fid file does not match parameters.');
    end
        
    fidFile=reshape(fidFile,blockSize,numDataHighDim*NI*NR); % in most cases unnecessary
   
    % for faster execution: minimize usage of the permute-command
    if blockSize ~= ACQ_size(1)*numSelectedReceivers %remove zero-lines
        fidFile=permute(fidFile,[2,1]); %for faster memory access during 2 following operations
        fidFile=fidFile(:,1:ACQ_size(1)*numSelectedReceivers);
        % select channels for new dimension:  
        fidFile=reshape(fidFile,[numDataHighDim*NI*NR, ACQ_size(1) ,numSelectedReceivers]); 
           
        % resort dimensions
        fidFile=permute(fidFile,[3,2,1]);
    else 
        fidFile=reshape(fidFile,[ACQ_size(1), numSelectedReceivers, numDataHighDim*NI*NR]);
        fidFile=permute(fidFile,[2 1 3]);
    end
    
    
    
    % Save to output variable:
    if isComplexRaw
        % convert to complex:
        fidFile=complex(fidFile(:,1:2:end,:,:), fidFile(:,2:2:end,:,:));
    % else: don't convert, only save
    end
    
end

function [ JobsCell ] = readJobFilesTillPv360(paramStruct, path_to_dataFile, isComplexRaw, specified_job, precision,format,bits, endian,numSelectedReceivers)
% specified_jobs or empty entry:
    if(isempty(specified_job))
        jobs=[0:paramStruct.ACQ_jobs_size-1];
    else
        jobs=specified_job;
    end
    clear specified_job;
    
    if max(jobs)>paramStruct.ACQ_jobs_size-1 || min(jobs)<0
        error('Your specified jobs are not correct !')
    end
    
    % check the value of precision and change it to a boolean
    if(strcmpi('double',precision))
        single_bool=false;
    elseif(strcmpi('single',precision))
        single_bool=true;
    else
        single_bool=false;
        disp('Your precision input is not correct! Set to double');
    end
    
    clear('input', 'precision');
    
% %----------------------------------------------------------------

    %% Failure Check: is data stored?
    
    % check if acqp-parameter is st correctly
    if(strcmpi(paramStruct.GO_data_save,'no'))
            error('myApp:argChk','You didn''t store your acqusition! Please change the parameters in ParaVision to save it.');
    end    
 
%----------------------------------------------------------------
    %% read jobs:
    for i=jobs
        % Modify path: before '../yourpath/fid'
        pos=strfind(path_to_dataFile, filesep); % last '/' is end of directory description
        path_to_dataFile=path_to_dataFile(1:pos(end)); % -> after: '../yourpath/'
        temppath_to_dataFile=[path_to_dataFile, 'rawdata.job', num2str(i)];
        
        %% Read Process:
        % open file       
        try
            fileID = fopen(temppath_to_dataFile,'r');
        catch
            fileID = -1;
        end
        if fileID == -1
            error('Cannot open parameter file. Problem opening file %s.',temppath_to_dataFile);
        end


        %read File to Variable X with fread() and make it single-precission with single():
        %  Attention: Matlab ACQ_size(1) = ACQ_size(0)
        if(single_bool)
            X=( fread(fileID, [numSelectedReceivers*paramStruct.ACQ_jobs(1,i+1), inf], [format, '=>single'], 0, endian) );
        else
            X=fread(fileID, [numSelectedReceivers*paramStruct.ACQ_jobs(1,i+1), inf], format, 0, endian);
        end
        
        dim1=numel(X) / (paramStruct.ACQ_jobs(1,i+1)*numSelectedReceivers);
        
        X = reshape(X,[paramStruct.ACQ_jobs(1,i+1), numSelectedReceivers, dim1]);
        X = permute(X, [2 1 3]);
     
        % Save to output variable:
        if isComplexRaw
            % convert to complex:
            X=complex(X(:,1:2:end,:), X(:,2:2:end,:));
        % else: don't convert, only save
        end

        % file close
        fclose(fileID);

        % Add to struct:
        
        JobsCell{i+1}=X;
    end

end


%----------------------------------------------------------------
function [ data , addInfo] = readBrukerRawFromPv360(Acqp, Method, varargin)
    %% Define default-value if necesseary:
    
    % Set Parameters of InputParser (Matlab-function)
    [varargin, specified_NRs]=bruker_addParamValue(varargin, 'specified_NRs', '@(x) isnumeric(x)', []);
    [varargin, specified_Jobs]=bruker_addParamValue(varargin, 'specified_Jobs', '@(x) isnumeric(x)', []);
    [varargin, precision]=bruker_addParamValue(varargin, 'precision', '@(x) (strcmpi(x,''double'') || strcmpi(x,''single''))', 'double');
    [varargin, fid_proc]=bruker_addFlag(varargin, 'fid_proc', false);

    if length(varargin) == 1
        path_to_dataFile=varargin{1};
    elseif isempty(varargin) 
        path_to_dataFile=[filesep, 'fid'];
    else
        warning('MATLAB:bruker_warning', 'Check your input arguments of function readBrukerRaw')
    end
    
%----------------------------------------------------------------   
    %% Check for missing variables in structs:
    cellstruct{1}=Acqp;
    all_here = bruker_requires(cellstruct, {'Acqp','ACQ_jobs','ACQ_ScanPipeJobSettings','ACQ_jobs_size'});
    clear cellstruct;
    if ~all_here
        error('Some parameters are missing');
    end

%----------------------------------------------------------------
    %% copy necessary parameters from inputstructs\
    % under this section, the Acqp-struct is not used !
    % makes it easier to find failing parameters for users
    BYTORDA=Acqp.BYTORDA;
    
    % Determining number of selected receive channels
    for jobIdx=0:(Acqp.ACQ_jobs_size-1)
        addInfo.numSelectedReceiversPerJob(jobIdx+1)=bruker_getSelectedReceivers(Acqp, jobIdx);
    end
    if ~isempty(specified_NRs)
        addInfo.specified_NRs=specified_NRs;
    end
    if ~isempty(specified_Jobs)
        addInfo.specified_Jobs=specified_Jobs;
    end
    
    %saving the variables to an struct to make function-calls shorter
    paramStruct.ACQ_jobs=Acqp.ACQ_jobs;
    paramStruct.ACQ_jobs_size=Acqp.ACQ_jobs_size;
    paramStruct.ACQ_ScanPipeJobSettings=Acqp.ACQ_ScanPipeJobSettings;
    paramStruct.numSelectedReceiversPerJob=addInfo.numSelectedReceiversPerJob;
    if isfield(Method, 'PVM_EncMatrix')
        paramStruct.PVM_EncMatrix=Method.PVM_EncMatrix;
    end
    if isfield(Method, 'SpecSize')
        paramStruct.SpecSize=Method.SpecSize;
    end
    

    %----------------------------------------------------------------------
    %% Transform Variables from Acqp-Struct to Matlab readable:

    %transform the machinecode-format to matlab-format (=endian)
    switch(BYTORDA)
        case ('little')
            endian='l';
        case ('big')
            endian='b';
        otherwise 
            endian='l';
            disp('MachineCode-Format not correct specified! Set to little-endian')
    end
    
    %----------------------------------------------------------------------    
    
    if fid_proc
        [ data{1} ] = readFidProcFile(Acqp, paramStruct, path_to_dataFile, specified_NRs, precision, endian);
    elseif (length(specified_Jobs)==1 && ~(specified_Jobs(1)==-1) || length(specified_Jobs)~=1 )
        % Added by David to account for EPI images!!!
        if ~isempty(strfind(Acqp.ACQ_method,'EPI'))
            paramStruct.ACQ_jobs{1,1} = paramStruct.PVM_EncMatrix(1)*2;
            [ data ] = readJobFiles(paramStruct, path_to_dataFile, specified_Jobs, precision, endian);
        else
            [ data ] = readJobFiles(paramStruct, path_to_dataFile, specified_Jobs, precision, endian);
        end
    else
        error('Your AcqpFile has an unallowed job-description, or you specification was not correct');
    end    
end
            
function [ JobsCell ] = readJobFiles(paramStruct, path_to_dataFile, specified_job, precision, endian)
% specified_jobs or empty entry:
    if(isempty(specified_job))
        jobs=[0:paramStruct.ACQ_jobs_size-1];
    else
        jobs=specified_job;
    end
    clear specified_job;
    
    if max(jobs)>paramStruct.ACQ_jobs_size-1 || min(jobs)<0
        error('Your specified jobs are not correct !')
    end
    
    % check the value of precision and change it to a boolean
    if(strcmpi('double',precision))
        single_bool=false;
    elseif(strcmpi('single',precision))
        single_bool=true;
    else
        single_bool=false;
        disp('Your precision input is not correct! Set to double');
    end
    
    clear('input', 'precision');
    
% %----------------------------------------------------------------

    %% Failure Check: is data stored?
    
    % check if acqp-parameter is st correctly
    anyStored = false;
    for i=1:size(paramStruct.ACQ_ScanPipeJobSettings,2)
        if ~strcmpi(paramStruct.ACQ_ScanPipeJobSettings(1, i, :), 'STORE_discard');
            anyStored = true;
        end
    end
    if(~anyStored)
        error('myApp:argChk','You didn''t store your acqusition! Please change the parameters in ParaVision to save it.');
    end    
 
%----------------------------------------------------------------
    %% read jobs:
    for i=jobs
        if strcmpi(paramStruct.ACQ_ScanPipeJobSettings(1, i+1, :), 'STORE_discard');
            continue;
        end
        jobScanSize = paramStruct.ACQ_jobs(1,i+1);
        jobName = paramStruct.ACQ_jobs(9,i+1);
        jobChan = paramStruct.ACQ_jobs(8,i+1);
        nRecs = paramStruct.numSelectedReceiversPerJob(i+1);
        
        %transform the Number-Format to Matlab-format (=format)
        if strcmpi(paramStruct.ACQ_ScanPipeJobSettings(2, i+1), 'STORE_32bit_signed');
            format='int32';
        elseif strcmpi(paramStruct.ACQ_ScanPipeJobSettings(2, i+1), 'STORE_64bit_float');
            format='float64';
        else
            format='int32';
            disp('Data-Format not correct specified! Set to int32')
        end
                        
        % Modify path: before '../yourpath/fid'
        pos=strfind(path_to_dataFile, filesep); % last '/' is end of directory description
        path_to_dataFile=path_to_dataFile(1:pos(end)); % -> after: '../yourpath/'
        temppath_to_dataFile=[path_to_dataFile, 'rawdata.', jobName{1,1}];
        
        %% Read Process:
        % open file       
        try
            fileID = fopen(temppath_to_dataFile,'r');
        catch
            fileID = -1;
        end
        if fileID == -1
            error('Cannot open parameter file. Problem opening file %s.',temppath_to_dataFile);
        end

        %read File to Variable X with fread() and make it single-precission with single():
        if(single_bool)
            X=( fread(fileID, [nRecs*jobScanSize{1,1}, inf], [format, '=>single'], 0, endian) );
        else
            X=fread(fileID, [nRecs*jobScanSize{1,1}, inf], format, 0, endian);
        end
        
        dim1=numel(X) / (jobScanSize{1,1}*nRecs);
        
        X = reshape(X,[jobScanSize{1,1}, nRecs, dim1]);
        X = permute(X, [2 1 3]);
     
        % Save to output variable:
        % convert to complex:
        X=complex(X(:,1:2:end,:), X(:,2:2:end,:));

        % file close
        fclose(fileID);

        % Add to struct:
        
        JobsCell{i+1}=X;
    end

end

% Read an pre-processed '<EXPNO>/fid', or '<PROCNO>/fid_proc.64' for ParaVision 360 V3.0
% and later, respectively. This pre-processed fid, as created by some methods (e.g., CSI,
% PRESS and STEAM) is created from the raw data by performing phase corrections, averages, 
% combining the receive channels and (for CSI) Fourier transforming in the spatial
% direction(s).
function [ data ] = readFidProcFile(Acqp, paramStruct, path_to_dataFile, specified_NRs, precision, endian)
    if isempty(strfind(Acqp.ACQ_method,'CSI')) && ...
       isempty(strfind(Acqp.ACQ_method,'PRESS')) && ...
       isempty(strfind(Acqp.ACQ_method,'STEAM')) && ...
       isempty(strfind(Acqp.ACQ_method,'NSPECT')) && ...
       isempty(strfind(Acqp.ACQ_method,'ISIS')) && ...
       isempty(strfind(Acqp.ACQ_method,'EPSI')) && ...
       isempty(strfind(Acqp.ACQ_method,'SLASER'))
        warning('MATLAB:bruker_warning', ['''fid_proc'' option not supported ' ...
            'for method '  Acqp.ACQ_method '. You may get unexpected results.']);
    end

    % fid_proc is always complex
    isComplexRaw = true;

    % receivers are already combined in fid_proc
    numReceivers = 1;

    paramStruct.NI=Acqp.NI;
    paramStruct.NR=Acqp.NR;
    paramStruct.ACQ_size=bruker_getAcqSizes(Acqp, paramStruct);

    % Data is always stored in fid/fid_proc.64
    paramStruct.GO_data_save = 'Yes';
    
    % Is data is stored in zero-padded blocks of 1 kiB?
    if ~bruker_getAcqPvVersion(Acqp, 'is360') 
        paramStruct.GO_block_size = Acqp.GO_block_size;
    else
        pv360major = bruker_getAcqPvVersion(Acqp, 'major');
        if (pv360major == 2 && ~isempty(strfind(Acqp.ACQ_method,'EPSI'))) ...
                || pv360major >= 3
            paramStruct.GO_block_size='continuous';
        else
            paramStruct.GO_block_size='Standard_KBlock_Format';
        end
    end
    
    format = 'int32'; % signed integer
    bits = 32;
    
    if bruker_getAcqPvVersion(Acqp, 'is360')
        pv360major = bruker_getAcqPvVersion(Acqp, 'major');
        if (strcmp(Acqp.ACQ_method(end-2:end),'CSI') && isempty(strfind(bruker_getAcqPvVersion(Acqp), 'PV-360.1.0'))) ...
                || (pv360major == 2 && ~isempty(strfind(Acqp.ACQ_method,'EPSI'))) ...
                || (pv360major >= 3)
            % CSI stores fid_proc in double precision floating point
            % starting from V1.1, the other spectral methods starting from
            % V3.0
            format = 'float64'; % double-precision floating point
            bits = 64;
        end
    end    
    
    % Added by David to try to process EPSI images
    

    if ~isempty(strfind(Acqp.ACQ_method,'EPSI'))
        paramStruct.ACQ_size = [paramStruct.ACQ_size(1)/paramStruct.PVM_EncMatrix(1)*paramStruct.ACQ_size(2), paramStruct.PVM_EncMatrix(1), paramStruct.PVM_EncMatrix(2)];
    end


    data = readfidFile(paramStruct, path_to_dataFile, isComplexRaw, specified_NRs, ...
        precision, format, bits, endian, numReceivers);

    if ~isempty(strfind(Acqp.ACQ_method,'EPSI'))
        dsi = size(data);
        dd = reshape(data, 1, dsi(2)*dsi(3));
        dd2 = reshape(dd, paramStruct.ACQ_size(2),paramStruct.ACQ_size(1)/2,paramStruct.ACQ_size(3));
        dd3 = permute(dd2,[2,1,3]);
    
        data = reshape(dd3, dsi);
    end




end
