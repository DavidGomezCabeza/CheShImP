function [ data ] = convertFrameToCKData( data, Acqp, varargin )
% function ckdata = convertFrameToCKData(frame, Acqp, Method, ['specified_NRs', NRarray], ['useMethod', useMethod])
% Attention: Currently works with RARE, FLASH, MSME, FISP only.
%
% Input:
%   frame: frame data as generated by convertRawToFrame 
%
%   Acqp (struct): An acqp struct as generated by the function readBrukerParamFile('path/acqp')
%
% Optional Input:
%   Method: A method struct generated by the function readBrukerParamFile('path/method')
%           This input is only required if useMethod is true
%
%   'specified_NRs', NRarray: A list of repetitions to be converted, NR starting with 1 
%                             'specified_NRs',[2 5 7] -> only NR 2, 5 and 7 are converted
%
%   'useMethod', useMethod: Used to specify whether the method parameters should be used,
%                           e.g. set useMethod to false when required parameters in the
%                           method file are missing. Default is true.
%
% Output:
%   ckdata: 7D Cartesian k-space matrix, with dimensions 
%           (dim1, dim2, dim3, dim4, NumberOfChannels, NumberOfObjects, NumberOfRepetitions)


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Copyright (c) 2013-2021
% Bruker BioSpin MRI GmbH
% D-76275 Ettlingen, Germany
%
% All Rights Reserved
%
% $Id$
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


    %% Define default-value if necesseary:
    [varargin, specified_NRs]=bruker_addParamValue(varargin, 'specified_NRs', '@(x) isnumeric(x)', []);
    [varargin, useMethod] =bruker_addParamValue(varargin, 'useMethod', '@(x) islogical(x)', true);
    
    if length(varargin) == 1
        Method=varargin{1};
    elseif isempty(varargin) 
        Method=struct();
    else
        warning('MATLAB:bruker_warning', 'Check your input arguments of function readBrukerRaw')
    end
    
    
    % Check for missing variables in structs:
    cellstruct{1}=Acqp;
    if useMethod
        cellstruct{2}=Method;
        all_here = bruker_requires(cellstruct, {'Acqp','NI','NR','ACQ_dim'}, {'Method', 'PVM_Matrix', 'PVM_EncSteps1'});
    else
        all_here = bruker_requires(cellstruct, {'Acqp','NI','NR','ACQ_dim'});
    end
    clear cellstruct;
    if ~all_here
        error('Some parameters are missing. You can try: ''useMethod'', false');
    end
    
    %Init:
    if bruker_getAcqPvVersion(Acqp, 'is360')
        AQ_mod='qdig';
    else
        if ~isfield(Acqp, 'AQ_mod')
            error('AQ_mod parameter is missing.');
        end
        AQ_mod=Acqp.AQ_mod;
    end
    NI=Acqp.NI;
    if ~isempty(specified_NRs)
        NR=length(specified_NRs);
    else
        NR=Acqp.NR; 
    end
    ACQ_size=bruker_getAcqSizes(Acqp,Method);
    
    
    %% Modified by David
    % It seems that the acquisition file says that it is a 3D image,
    % although it should be a 2D
    ACQ_dim=Acqp.ACQ_dim;
%     ACQ_dim=2;
    
    if useMethod % don't read when method=disabled
        if ACQ_dim==3
            if isfield(Method, 'PVM_EncSteps2')
                PVM_EncSteps2=Method.PVM_EncSteps2;
            else
                error('Method.PVM_EncStep2 is missing!');
            end
        end       
        PVM_Matrix=Method.PVM_Matrix;
        PVM_EncSteps1=Method.PVM_EncSteps1;
        if isfield(Method, 'PVM_AntiAlias')
            PVM_AntiAlias=Method.PVM_AntiAlias;
        else
            % No anti-aliasing available.
            PVM_AntiAlias=ones(1, ACQ_dim);
        end
        if isfield(Method, 'PVM_EncZf')
            PVM_EncZf=Method.PVM_EncZf;
        else
            % No zero-filling/interpolation available.
            PVM_EncZf=ones(1, ACQ_dim);
        end
    end
    
    % read precision:
    temp=whos('data');
    precision=temp.class;
    clear temp;

    %% Calculate additional Parameters  
    
     % decide if RawFile is complex or real:
    switch AQ_mod
        case ('qf')
            isComplex=false;
        case ('qseq')
            isComplex=true;
        case ('qsim')
            isComplex=true;
        case ('qdig')
            isComplex=true;
        otherwise
            error('The value of parameter AQ_mod is not supported');
    end
    
    
    numSelectedReceivers=size(data,3);
    
    % Added by David
    if ~isempty(strfind(Acqp.ACQ_method,'EPSI'))
        if isComplex
            ACQ_size = [ACQ_size(2)*2, ACQ_size(1)/2, ACQ_size(3)];
        else
            ACQ_size = [ACQ_size(2), ACQ_size(1), ACQ_size(3)];
        end
    end


    % Convert if complex: to blockSize of a complex Matrix and change
    % ACQ_size(1)
    if isComplex
        scanSize=ACQ_size(1)/2;
    else
        scanSize=ACQ_size(1);
    end

   %% Resort Matrix
   if useMethod
       % use also method-parameters (encoding group)

       frameData=data;

       % MGE with alternating k-space readout: Reverse every second
       % scan. As in this case the method ensures that the number of 
       % echos is even, the reversal can happen in one step, also for 
       % multi-slice mode.
       if isfield(Method, 'EchoAcqMode') && strcmpi(Method.EchoAcqMode, 'allEchoes') == true
           frameData(:,:,:,2:2:end,:)=flipdim(data(:,:,:,2:2:end,:),1);
       end

       % Calculate size of Cartesian k-space
       % Step 1: Anti-Aliasing
       ckSize=round(PVM_AntiAlias.*PVM_Matrix);
       % Step 2: Interpolation 
       % Interpolation reduces the required k-space samples, and these
       % k-space points will later be zero-filled by the reconstruction. 
       % Zero-filling is done always by an even number.
       reduceZf=2*fix((ckSize - ckSize./PVM_EncZf)/2);
       ckSize=ckSize-reduceZf;
       % index of central k-space point (+1 for 1-based indexing in MATLAB)
       ckCenterIndex = fix(ckSize/2 + 0.25) + 1;
       % Note on the usage of fix/floor and offset 0.25:
       % cKSize are integers, so cKSize/2 is always either an integer or 
       % an integer+0.5. The target is to use the integer (as is) or the 
       % integer below the half-integer. Due to small numerical deviations,
       % cKSize/2 can be a little bit smaller than an integer, in which 
       % case fix() would find the smaller integer, cKSize/2-1 (wrong).
       % Shifting cKSize/2 upwards by an offset of 0.25 always results 
       % in the correct indices, even in case of numerical jitter. Since 
       % the argument to fix() is always positive, using fix() or floor() 
       % is equivalent.
       %
       % Step 3: Partial TF / Acceleration
       % Partial FT and encoding scheme in the phase encoding directions is 
       % taken into account via PVM_EncSteps below. For partial FT in read
       % direction, the sampling offset by the methods is such that the 
       % echo time can be made minimal (+1 for 1-based indexing in MATLAB).
       
       %% Modified by David

       switch ACQ_dim
           case 1
                readStartIndex=ckSize(1)-scanSize + 1;
           case 2
                readStartIndex=ckSize(1)-scanSize + 1;
           case 3
                readStartIndex=ACQ_size(1)-scanSize + 1;
       end
%        readStartIndex=ckSize(1)-scanSize + 1;
%        readStartIndex=ACQ_size(1)-scanSize + 1;
       
       %%
       
       
       % Reshape & store
       switch ACQ_dim
           case 1
               frameData=reshape(frameData,[scanSize 1 1 1 numSelectedReceivers NI NR]);
               data=zeros([ckSize(1) 1 1 1 numSelectedReceivers NI NR],precision);
               data(readStartIndex:end,1,1,1,:,:,:)=frameData;
           case 2
               frameData=reshape(frameData,[scanSize ACQ_size(2) 1 1 numSelectedReceivers NI NR]);
               data=zeros([ckSize(1) ckSize(2) 1 1 numSelectedReceivers NI NR],precision);
               encSteps1indices = PVM_EncSteps1 + ckCenterIndex(2);
               data(readStartIndex:end,encSteps1indices,1,1,:,:,:)=frameData;               
           case 3
               
               frameData=reshape(frameData,[scanSize ACQ_size(2) ACQ_size(3) 1 numSelectedReceivers NI NR]);
               %% Modified by David
%                frameData=reshape(frameData,[ACQ_size(2) ACQ_size(3) scanSize 1 numSelectedReceivers NI NR]);

               
%                data=zeros([ckSize(1) ckSize(2) ckSize(3) 1 numSelectedReceivers NI NR],precision);
               data=zeros([ACQ_size(1)/2 ACQ_size(2) ACQ_size(3) 1 numSelectedReceivers NI NR],precision);
%                data=zeros([ckSize(1) ckSize(2) ACQ_size(1)/2 1 numSelectedReceivers NI NR],precision);
               
%                encSteps1indices = PVM_EncSteps1 + ckCenterIndex(2);
%                encSteps2indices = PVM_EncSteps2 + ckCenterIndex(3);
               encSteps1indices = PVM_EncSteps1 + ckCenterIndex(1);
               encSteps2indices = PVM_EncSteps1 + ckCenterIndex(2);
               
%                data(readStartIndex:end,encSteps1indices,encSteps2indices,1,:,:,:)=frameData;
%                data(readStartIndex:end,encSteps1indices,encSteps2indices,1,:,:,:)=frameData;
               
%                data(encSteps1indices,encSteps2indices,1:readStartIndex-1,1,:,:,:)=frameData;
                try
                    if Method.PVM_EncStart(1) == 0 || Method.PVM_EncStart(2) == 0
                        encSteps1indices = 1:ACQ_size(2);
                        encSteps2indices = 1:ACQ_size(3);
                    end
%                     if Method.PVM_EncStart(2) == 0
%                         encSteps1indices = 1:ACQ_size(2);
%                         encSteps2indices = 1:ACQ_size(3);
%                     end

                    data(1:readStartIndex-1,encSteps1indices,encSteps2indices,1,:,:,:)=frameData;
                catch
                    encSteps1indices = Method.PVM_EncSteps0 + ckCenterIndex(1);
%                     encSteps2indices = PVM_EncSteps1 + ckCenterIndex(2);
%                     encSteps2indices = 1:ACQ_size(3);
                    if Method.PVM_EncStart(1) == 0 || Method.PVM_EncStart(2) == 0
                        encSteps1indices = 1:ACQ_size(2);
                        encSteps2indices = 1:ACQ_size(3);
                    end
%                     if Method.PVM_EncStart(2) == 0
%                         encSteps2indices = 1:ACQ_size(3);
%                     end
                    data(1:readStartIndex-1,encSteps1indices,encSteps2indices,1,:,:,:)=frameData;
                end
               %%
               
           otherwise
               error('Unknown ACQ_dim with useMethod');
       end
       clear frameData;

   else % <- useMethod=false
       % use acqp-parameters instead:
       if ACQ_dim>1

            % Reshape:
            if ACQ_dim==2
                data=reshape(data,[ scanSize ACQ_size(2) 1 1 numSelectedReceivers NI NR]);
                
            elseif ACQ_dim==3
                data=reshape(data,[ scanSize ACQ_size(2) ACQ_size(3) 1 numSelectedReceivers NI NR]);
            elseif ACQ_dim==4
                data=reshape(data,[ scanSize ACQ_size(2) ACQ_size(3) ACQ_size(4) numSelectedReceivers NI NR]);               
            else
                error('Unknown ACQ_dim.');
            end

        else
            % dim=1:
            data=reshape(data,scanSize,1,1,1,numSelectedReceivers,NI,NR);
       end
   end

end

